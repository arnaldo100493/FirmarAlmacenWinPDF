// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   Image.java

package co.com.pdf.text;

import co.com.pdf.awt.PdfGraphics2D;
import co.com.pdf.text.api.Indentable;
import co.com.pdf.text.api.Spaceable;
import co.com.pdf.text.error_messages.MessageLocalization;
import co.com.pdf.text.pdf.ICC_Profile;
import co.com.pdf.text.pdf.PRIndirectReference;
import co.com.pdf.text.pdf.PdfArray;
import co.com.pdf.text.pdf.PdfContentByte;
import co.com.pdf.text.pdf.PdfDictionary;
import co.com.pdf.text.pdf.PdfIndirectReference;
import co.com.pdf.text.pdf.PdfName;
import co.com.pdf.text.pdf.PdfNumber;
import co.com.pdf.text.pdf.PdfOCG;
import co.com.pdf.text.pdf.PdfObject;
import co.com.pdf.text.pdf.PdfReader;
import co.com.pdf.text.pdf.PdfString;
import co.com.pdf.text.pdf.PdfTemplate;
import co.com.pdf.text.pdf.PdfWriter;
import co.com.pdf.text.pdf.RandomAccessFileOrArray;
import co.com.pdf.text.pdf.codec.BmpImage;
import co.com.pdf.text.pdf.codec.CCITTG4Encoder;
import co.com.pdf.text.pdf.codec.GifImage;
import co.com.pdf.text.pdf.codec.JBIG2Image;
import co.com.pdf.text.pdf.codec.PngImage;
import co.com.pdf.text.pdf.codec.TiffImage;
import co.com.pdf.text.pdf.interfaces.IAccessibleElement;
import co.com.pdf.text.pdf.interfaces.IAlternateDescription;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.PixelGrabber;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Constructor;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;

// Referenced classes of package co.com.pdf.text:
//            Rectangle, Jpeg, Jpeg2000, ImgWMF, 
//            ImgJBIG2, BadElementException, ImgCCITT, ImgRaw, 
//            ImgTemplate, ExceptionConverter, DocumentException, AccessibleElementId, 
//            Utilities, Annotation

public abstract class Image extends Rectangle
    implements Indentable, Spaceable, IAccessibleElement, IAlternateDescription
{

    public Image(URL url)
    {
        super(0.0F, 0.0F);
        bpc = 1;
        template = new PdfTemplate[1];
        absoluteX = (0.0F / 0.0F);
        absoluteY = (0.0F / 0.0F);
        compressionLevel = -1;
        mySerialId = getSerialId();
        role = PdfName.FIGURE;
        accessibleAttributes = null;
        id = null;
        indentationLeft = 0.0F;
        indentationRight = 0.0F;
        widthPercentage = 100F;
        scaleToFitHeight = true;
        annotation = null;
        originalType = 0;
        deflated = false;
        dpiX = 0;
        dpiY = 0;
        XYRatio = 0.0F;
        colorspace = -1;
        colortransform = 1;
        invert = false;
        profile = null;
        additional = null;
        mask = false;
        this.url = url;
        alignment = 0;
        rotationRadians = 0.0F;
    }

    public static Image getInstance(URL url)
        throws BadElementException, MalformedURLException, IOException
    {
        return getInstance(url, false);
    }

    public static Image getInstance(URL url, boolean handleIncorrectImage)
        throws BadElementException, MalformedURLException, IOException
    {
        InputStream is = null;
        int c1;
        int c2;
        int c3;
        int c4;
        int c5;
        int c6;
        int c7;
        int c8;
        Image image;
        is = url.openStream();
        c1 = is.read();
        c2 = is.read();
        c3 = is.read();
        c4 = is.read();
        c5 = is.read();
        c6 = is.read();
        c7 = is.read();
        c8 = is.read();
        is.close();
        is = null;
        if(c1 != 71 || c2 != 73 || c3 != 70)
            break MISSING_BLOCK_LABEL_113;
        GifImage gif = new GifImage(url);
        Image img = gif.getImage(1);
        image = img;
        if(is != null)
            is.close();
        return image;
        RandomAccessFileOrArray ra;
        if(c1 != 255 || c2 != 216)
            break MISSING_BLOCK_LABEL_149;
        ra = new Jpeg(url);
        if(is != null)
            is.close();
        return ra;
        if(c1 != 0 || c2 != 0 || c3 != 0 || c4 != 12)
            break MISSING_BLOCK_LABEL_191;
        ra = new Jpeg2000(url);
        if(is != null)
            is.close();
        return ra;
        if(c1 != 255 || c2 != 79 || c3 != 255 || c4 != 81)
            break MISSING_BLOCK_LABEL_241;
        ra = new Jpeg2000(url);
        if(is != null)
            is.close();
        return ra;
        if(c1 != PngImage.PNGID[0] || c2 != PngImage.PNGID[1] || c3 != PngImage.PNGID[2] || c4 != PngImage.PNGID[3])
            break MISSING_BLOCK_LABEL_297;
        ra = PngImage.getImage(url);
        if(is != null)
            is.close();
        return ra;
        if(c1 != 215 || c2 != 205)
            break MISSING_BLOCK_LABEL_333;
        ra = new ImgWMF(url);
        if(is != null)
            is.close();
        return ra;
        if(c1 != 66 || c2 != 77)
            break MISSING_BLOCK_LABEL_363;
        ra = BmpImage.getImage(url);
        if(is != null)
            is.close();
        return ra;
        if((c1 != 77 || c2 != 77 || c3 != 0 || c4 != 42) && (c1 != 73 || c2 != 73 || c3 != 42 || c4 != 0))
            break MISSING_BLOCK_LABEL_520;
        ra = null;
        if(url.getProtocol().equals("file"))
        {
            String file = url.getFile();
            file = Utilities.unEscapeURL(file);
            ra = new RandomAccessFileOrArray(file);
        } else
        {
            ra = new RandomAccessFileOrArray(url);
        }
        Image img = TiffImage.getTiffImage(ra, handleIncorrectImage, 1);
        img.url = url;
        image = img;
        if(ra != null)
            ra.close();
        if(is != null)
            is.close();
        return image;
        Exception exception;
        exception;
        if(ra != null)
            ra.close();
        throw exception;
        if(c1 != 151 || c2 != 74 || c3 != 66 || c4 != 50 || c5 != 13 || c6 != 10 || c7 != 26 || c8 != 10)
            break MISSING_BLOCK_LABEL_682;
        ra = null;
        if(url.getProtocol().equals("file"))
        {
            String file = url.getFile();
            file = Utilities.unEscapeURL(file);
            ra = new RandomAccessFileOrArray(file);
        } else
        {
            ra = new RandomAccessFileOrArray(url);
        }
        Image img = JBIG2Image.getJbig2Image(ra, 1);
        img.url = url;
        image = img;
        if(ra != null)
            ra.close();
        if(is != null)
            is.close();
        return image;
        Exception exception1;
        exception1;
        if(ra != null)
            ra.close();
        throw exception1;
        throw new IOException(MessageLocalization.getComposedMessage("unknown.image.format", new Object[] {
            url.toString()
        }));
        Exception exception2;
        exception2;
        if(is != null)
            is.close();
        throw exception2;
    }

    public static Image getInstance(String filename)
        throws BadElementException, MalformedURLException, IOException
    {
        return getInstance(Utilities.toURL(filename));
    }

    public static Image getInstance(String filename, boolean handleIncorrectImage)
        throws IOException, BadElementException
    {
        return getInstance(Utilities.toURL(filename), handleIncorrectImage);
    }

    public static Image getInstance(byte imgb[])
        throws BadElementException, MalformedURLException, IOException
    {
        return getInstance(imgb, false);
    }

    public static Image getInstance(byte imgb[], boolean handleIncorrectImage)
        throws BadElementException, MalformedURLException, IOException
    {
        InputStream is = null;
        int c1;
        int c2;
        int c3;
        int c4;
        Image image;
        is = new ByteArrayInputStream(imgb);
        c1 = is.read();
        c2 = is.read();
        c3 = is.read();
        c4 = is.read();
        is.close();
        is = null;
        if(c1 != 71 || c2 != 73 || c3 != 70)
            break MISSING_BLOCK_LABEL_89;
        GifImage gif = new GifImage(imgb);
        image = gif.getImage(1);
        if(is != null)
            is.close();
        return image;
        RandomAccessFileOrArray ra;
        if(c1 != 255 || c2 != 216)
            break MISSING_BLOCK_LABEL_125;
        ra = new Jpeg(imgb);
        if(is != null)
            is.close();
        return ra;
        if(c1 != 0 || c2 != 0 || c3 != 0 || c4 != 12)
            break MISSING_BLOCK_LABEL_167;
        ra = new Jpeg2000(imgb);
        if(is != null)
            is.close();
        return ra;
        if(c1 != 255 || c2 != 79 || c3 != 255 || c4 != 81)
            break MISSING_BLOCK_LABEL_217;
        ra = new Jpeg2000(imgb);
        if(is != null)
            is.close();
        return ra;
        if(c1 != PngImage.PNGID[0] || c2 != PngImage.PNGID[1] || c3 != PngImage.PNGID[2] || c4 != PngImage.PNGID[3])
            break MISSING_BLOCK_LABEL_273;
        ra = PngImage.getImage(imgb);
        if(is != null)
            is.close();
        return ra;
        if(c1 != 215 || c2 != 205)
            break MISSING_BLOCK_LABEL_309;
        ra = new ImgWMF(imgb);
        if(is != null)
            is.close();
        return ra;
        if(c1 != 66 || c2 != 77)
            break MISSING_BLOCK_LABEL_339;
        ra = BmpImage.getImage(imgb);
        if(is != null)
            is.close();
        return ra;
        if((c1 != 77 || c2 != 77 || c3 != 0 || c4 != 42) && (c1 != 73 || c2 != 73 || c3 != 42 || c4 != 0))
            break MISSING_BLOCK_LABEL_465;
        ra = null;
        Image image1;
        ra = new RandomAccessFileOrArray(imgb);
        Image img = TiffImage.getTiffImage(ra, 1, handleIncorrectImage);
        if(img.getOriginalData() == null)
            img.setOriginalData(imgb);
        image1 = img;
        if(ra != null)
            ra.close();
        if(is != null)
            is.close();
        return image1;
        Exception exception;
        exception;
        if(ra != null)
            ra.close();
        throw exception;
        RandomAccessFileOrArray ra;
        if(c1 != 151 || c2 != 74 || c3 != 66 || c4 != 50)
            break MISSING_BLOCK_LABEL_688;
        is = new ByteArrayInputStream(imgb);
        is.skip(4L);
        int c5 = is.read();
        int c6 = is.read();
        int c7 = is.read();
        int c8 = is.read();
        if(c5 != 13 || c6 != 10 || c7 != 26 || c8 != 10)
            break MISSING_BLOCK_LABEL_688;
        int file_header_flags = is.read();
        int number_of_pages = -1;
        if((file_header_flags & 2) == 2)
            number_of_pages = is.read() << 24 | is.read() << 16 | is.read() << 8 | is.read();
        is.close();
        ra = null;
        Image image2;
        ra = new RandomAccessFileOrArray(imgb);
        Image img = JBIG2Image.getJbig2Image(ra, 1);
        if(img.getOriginalData() == null)
            img.setOriginalData(imgb);
        image2 = img;
        if(ra != null)
            ra.close();
        if(is != null)
            is.close();
        return image2;
        Exception exception1;
        exception1;
        if(ra != null)
            ra.close();
        throw exception1;
        throw new IOException(MessageLocalization.getComposedMessage("the.byte.array.is.not.a.recognized.imageformat", new Object[0]));
        Exception exception2;
        exception2;
        if(is != null)
            is.close();
        throw exception2;
    }

    public static Image getInstance(int width, int height, int components, int bpc, byte data[])
        throws BadElementException
    {
        return getInstance(width, height, components, bpc, data, ((int []) (null)));
    }

    public static Image getInstance(int width, int height, byte data[], byte globals[])
    {
        Image img = new ImgJBIG2(width, height, data, globals);
        return img;
    }

    public static Image getInstance(int width, int height, boolean reverseBits, int typeCCITT, int parameters, byte data[])
        throws BadElementException
    {
        return getInstance(width, height, reverseBits, typeCCITT, parameters, data, null);
    }

    public static Image getInstance(int width, int height, boolean reverseBits, int typeCCITT, int parameters, byte data[], int transparency[])
        throws BadElementException
    {
        if(transparency != null && transparency.length != 2)
        {
            throw new BadElementException(MessageLocalization.getComposedMessage("transparency.length.must.be.equal.to.2.with.ccitt.images", new Object[0]));
        } else
        {
            Image img = new ImgCCITT(width, height, reverseBits, typeCCITT, parameters, data);
            img.transparency = transparency;
            return img;
        }
    }

    public static Image getInstance(int width, int height, int components, int bpc, byte data[], int transparency[])
        throws BadElementException
    {
        if(transparency != null && transparency.length != components * 2)
            throw new BadElementException(MessageLocalization.getComposedMessage("transparency.length.must.be.equal.to.componentes.2", new Object[0]));
        if(components == 1 && bpc == 1)
        {
            byte g4[] = CCITTG4Encoder.compress(data, width, height);
            return getInstance(width, height, false, 256, 1, g4, transparency);
        } else
        {
            Image img = new ImgRaw(width, height, components, bpc, data);
            img.transparency = transparency;
            return img;
        }
    }

    public static Image getInstance(PdfTemplate template)
        throws BadElementException
    {
        return new ImgTemplate(template);
    }

    public PdfIndirectReference getDirectReference()
    {
        return directReference;
    }

    public void setDirectReference(PdfIndirectReference directReference)
    {
        this.directReference = directReference;
    }

    public static Image getInstance(PRIndirectReference ref)
        throws BadElementException
    {
        PdfDictionary dic = (PdfDictionary)PdfReader.getPdfObjectRelease(ref);
        int width = ((PdfNumber)PdfReader.getPdfObjectRelease(dic.get(PdfName.WIDTH))).intValue();
        int height = ((PdfNumber)PdfReader.getPdfObjectRelease(dic.get(PdfName.HEIGHT))).intValue();
        Image imask = null;
        PdfObject obj = dic.get(PdfName.SMASK);
        if(obj != null && obj.isIndirect())
        {
            imask = getInstance((PRIndirectReference)obj);
        } else
        {
            obj = dic.get(PdfName.MASK);
            if(obj != null && obj.isIndirect())
            {
                PdfObject obj2 = PdfReader.getPdfObjectRelease(obj);
                if(obj2 instanceof PdfDictionary)
                    imask = getInstance((PRIndirectReference)obj);
            }
        }
        Image img = new ImgRaw(width, height, 1, 1, null);
        img.imageMask = imask;
        img.directReference = ref;
        return img;
    }

    protected Image(Image image)
    {
        super(image);
        bpc = 1;
        template = new PdfTemplate[1];
        absoluteX = (0.0F / 0.0F);
        absoluteY = (0.0F / 0.0F);
        compressionLevel = -1;
        mySerialId = getSerialId();
        role = PdfName.FIGURE;
        accessibleAttributes = null;
        id = null;
        indentationLeft = 0.0F;
        indentationRight = 0.0F;
        widthPercentage = 100F;
        scaleToFitHeight = true;
        annotation = null;
        originalType = 0;
        deflated = false;
        dpiX = 0;
        dpiY = 0;
        XYRatio = 0.0F;
        colorspace = -1;
        colortransform = 1;
        invert = false;
        profile = null;
        additional = null;
        mask = false;
        type = image.type;
        url = image.url;
        rawData = image.rawData;
        bpc = image.bpc;
        template = image.template;
        alignment = image.alignment;
        alt = image.alt;
        absoluteX = image.absoluteX;
        absoluteY = image.absoluteY;
        plainWidth = image.plainWidth;
        plainHeight = image.plainHeight;
        scaledWidth = image.scaledWidth;
        scaledHeight = image.scaledHeight;
        mySerialId = image.mySerialId;
        directReference = image.directReference;
        rotationRadians = image.rotationRadians;
        initialRotation = image.initialRotation;
        indentationLeft = image.indentationLeft;
        indentationRight = image.indentationRight;
        spacingBefore = image.spacingBefore;
        spacingAfter = image.spacingAfter;
        widthPercentage = image.widthPercentage;
        scaleToFitLineWhenOverflow = image.scaleToFitLineWhenOverflow;
        scaleToFitHeight = image.scaleToFitHeight;
        annotation = image.annotation;
        layer = image.layer;
        interpolation = image.interpolation;
        originalType = image.originalType;
        originalData = image.originalData;
        deflated = image.deflated;
        dpiX = image.dpiX;
        dpiY = image.dpiY;
        XYRatio = image.XYRatio;
        colorspace = image.colorspace;
        invert = image.invert;
        profile = image.profile;
        additional = image.additional;
        mask = image.mask;
        imageMask = image.imageMask;
        smask = image.smask;
        transparency = image.transparency;
        role = image.role;
        if(image.accessibleAttributes != null)
            accessibleAttributes = new HashMap(image.accessibleAttributes);
        setId(image.getId());
    }

    public static Image getInstance(Image image)
    {
        if(image == null)
            return null;
        try
        {
            Class cs = image.getClass();
            Constructor constructor = cs.getDeclaredConstructor(new Class[] {
                co/com/pdf/text/Image
            });
            return (Image)constructor.newInstance(new Object[] {
                image
            });
        }
        catch(Exception e)
        {
            throw new ExceptionConverter(e);
        }
    }

    public int type()
    {
        return type;
    }

    public boolean isNestable()
    {
        return true;
    }

    public boolean isJpeg()
    {
        return type == 32;
    }

    public boolean isImgRaw()
    {
        return type == 34;
    }

    public boolean isImgTemplate()
    {
        return type == 35;
    }

    public URL getUrl()
    {
        return url;
    }

    public void setUrl(URL url)
    {
        this.url = url;
    }

    public byte[] getRawData()
    {
        return rawData;
    }

    public int getBpc()
    {
        return bpc;
    }

    public PdfTemplate getTemplateData()
    {
        return template[0];
    }

    public void setTemplateData(PdfTemplate template)
    {
        this.template[0] = template;
    }

    public int getAlignment()
    {
        return alignment;
    }

    public void setAlignment(int alignment)
    {
        this.alignment = alignment;
    }

    public String getAlt()
    {
        return alt;
    }

    public void setAlt(String alt)
    {
        this.alt = alt;
        setAccessibleAttribute(PdfName.ALT, new PdfString(alt));
    }

    public void setAbsolutePosition(float absoluteX, float absoluteY)
    {
        this.absoluteX = absoluteX;
        this.absoluteY = absoluteY;
    }

    public boolean hasAbsoluteX()
    {
        return !Float.isNaN(absoluteX);
    }

    public float getAbsoluteX()
    {
        return absoluteX;
    }

    public boolean hasAbsoluteY()
    {
        return !Float.isNaN(absoluteY);
    }

    public float getAbsoluteY()
    {
        return absoluteY;
    }

    public float getScaledWidth()
    {
        return scaledWidth;
    }

    public float getScaledHeight()
    {
        return scaledHeight;
    }

    public float getPlainWidth()
    {
        return plainWidth;
    }

    public float getPlainHeight()
    {
        return plainHeight;
    }

    public void scaleAbsolute(Rectangle rectangle)
    {
        scaleAbsolute(rectangle.getWidth(), rectangle.getHeight());
    }

    public void scaleAbsolute(float newWidth, float newHeight)
    {
        plainWidth = newWidth;
        plainHeight = newHeight;
        float matrix[] = matrix();
        scaledWidth = matrix[6] - matrix[4];
        scaledHeight = matrix[7] - matrix[5];
        setWidthPercentage(0.0F);
    }

    public void scaleAbsoluteWidth(float newWidth)
    {
        plainWidth = newWidth;
        float matrix[] = matrix();
        scaledWidth = matrix[6] - matrix[4];
        scaledHeight = matrix[7] - matrix[5];
        setWidthPercentage(0.0F);
    }

    public void scaleAbsoluteHeight(float newHeight)
    {
        plainHeight = newHeight;
        float matrix[] = matrix();
        scaledWidth = matrix[6] - matrix[4];
        scaledHeight = matrix[7] - matrix[5];
        setWidthPercentage(0.0F);
    }

    public void scalePercent(float percent)
    {
        scalePercent(percent, percent);
    }

    public void scalePercent(float percentX, float percentY)
    {
        plainWidth = (getWidth() * percentX) / 100F;
        plainHeight = (getHeight() * percentY) / 100F;
        float matrix[] = matrix();
        scaledWidth = matrix[6] - matrix[4];
        scaledHeight = matrix[7] - matrix[5];
        setWidthPercentage(0.0F);
    }

    public void scaleToFit(Rectangle rectangle)
    {
        scaleToFit(rectangle.getWidth(), rectangle.getHeight());
    }

    public void scaleToFit(float fitWidth, float fitHeight)
    {
        scalePercent(100F);
        float percentX = (fitWidth * 100F) / getScaledWidth();
        float percentY = (fitHeight * 100F) / getScaledHeight();
        scalePercent(percentX >= percentY ? percentY : percentX);
        setWidthPercentage(0.0F);
    }

    public float[] matrix()
    {
        return matrix(1.0F);
    }

    public float[] matrix(float scalePercentage)
    {
        float matrix[] = new float[8];
        float cosX = (float)Math.cos(rotationRadians);
        float sinX = (float)Math.sin(rotationRadians);
        matrix[0] = plainWidth * cosX * scalePercentage;
        matrix[1] = plainWidth * sinX * scalePercentage;
        matrix[2] = -plainHeight * sinX * scalePercentage;
        matrix[3] = plainHeight * cosX * scalePercentage;
        if((double)rotationRadians < 1.5707963267948966D)
        {
            matrix[4] = matrix[2];
            matrix[5] = 0.0F;
            matrix[6] = matrix[0];
            matrix[7] = matrix[1] + matrix[3];
        } else
        if((double)rotationRadians < 3.1415926535897931D)
        {
            matrix[4] = matrix[0] + matrix[2];
            matrix[5] = matrix[3];
            matrix[6] = 0.0F;
            matrix[7] = matrix[1];
        } else
        if((double)rotationRadians < 4.7123889803846897D)
        {
            matrix[4] = matrix[0];
            matrix[5] = matrix[1] + matrix[3];
            matrix[6] = matrix[2];
            matrix[7] = 0.0F;
        } else
        {
            matrix[4] = 0.0F;
            matrix[5] = matrix[1];
            matrix[6] = matrix[0] + matrix[2];
            matrix[7] = matrix[3];
        }
        return matrix;
    }

    protected static synchronized Long getSerialId()
    {
        serialId++;
        return Long.valueOf(serialId);
    }

    public Long getMySerialId()
    {
        return mySerialId;
    }

    public float getImageRotation()
    {
        double d = 6.2831853071795862D;
        float rot = (float)((double)(rotationRadians - initialRotation) % d);
        if(rot < 0.0F)
            rot = (float)((double)rot + d);
        return rot;
    }

    public void setRotation(float r)
    {
        double d = 6.2831853071795862D;
        rotationRadians = (float)((double)(r + initialRotation) % d);
        if(rotationRadians < 0.0F)
            rotationRadians += d;
        float matrix[] = matrix();
        scaledWidth = matrix[6] - matrix[4];
        scaledHeight = matrix[7] - matrix[5];
    }

    public void setRotationDegrees(float deg)
    {
        double d = 3.1415926535897931D;
        setRotation((deg / 180F) * (float)d);
    }

    public float getInitialRotation()
    {
        return initialRotation;
    }

    public void setInitialRotation(float initialRotation)
    {
        float old_rot = rotationRadians - this.initialRotation;
        this.initialRotation = initialRotation;
        setRotation(old_rot);
    }

    public float getIndentationLeft()
    {
        return indentationLeft;
    }

    public void setIndentationLeft(float f)
    {
        indentationLeft = f;
    }

    public float getIndentationRight()
    {
        return indentationRight;
    }

    public void setIndentationRight(float f)
    {
        indentationRight = f;
    }

    public float getSpacingBefore()
    {
        return spacingBefore;
    }

    public void setSpacingBefore(float spacing)
    {
        spacingBefore = spacing;
    }

    public float getSpacingAfter()
    {
        return spacingAfter;
    }

    public void setSpacingAfter(float spacing)
    {
        spacingAfter = spacing;
    }

    public float getWidthPercentage()
    {
        return widthPercentage;
    }

    public void setWidthPercentage(float widthPercentage)
    {
        this.widthPercentage = widthPercentage;
    }

    public boolean isScaleToFitLineWhenOverflow()
    {
        return scaleToFitLineWhenOverflow;
    }

    public void setScaleToFitLineWhenOverflow(boolean scaleToFitLineWhenOverflow)
    {
        this.scaleToFitLineWhenOverflow = scaleToFitLineWhenOverflow;
    }

    public boolean isScaleToFitHeight()
    {
        return scaleToFitHeight;
    }

    public void setScaleToFitHeight(boolean scaleToFitHeight)
    {
        this.scaleToFitHeight = scaleToFitHeight;
    }

    public void setAnnotation(Annotation annotation)
    {
        this.annotation = annotation;
    }

    public Annotation getAnnotation()
    {
        return annotation;
    }

    public PdfOCG getLayer()
    {
        return layer;
    }

    public void setLayer(PdfOCG layer)
    {
        this.layer = layer;
    }

    public boolean isInterpolation()
    {
        return interpolation;
    }

    public void setInterpolation(boolean interpolation)
    {
        this.interpolation = interpolation;
    }

    public int getOriginalType()
    {
        return originalType;
    }

    public void setOriginalType(int originalType)
    {
        this.originalType = originalType;
    }

    public byte[] getOriginalData()
    {
        return originalData;
    }

    public void setOriginalData(byte originalData[])
    {
        this.originalData = originalData;
    }

    public boolean isDeflated()
    {
        return deflated;
    }

    public void setDeflated(boolean deflated)
    {
        this.deflated = deflated;
    }

    public int getDpiX()
    {
        return dpiX;
    }

    public int getDpiY()
    {
        return dpiY;
    }

    public void setDpi(int dpiX, int dpiY)
    {
        this.dpiX = dpiX;
        this.dpiY = dpiY;
    }

    public float getXYRatio()
    {
        return XYRatio;
    }

    public void setXYRatio(float XYRatio)
    {
        this.XYRatio = XYRatio;
    }

    public int getColorspace()
    {
        return colorspace;
    }

    public void setColorTransform(int c)
    {
        colortransform = c;
    }

    public int getColorTransform()
    {
        return colortransform;
    }

    public boolean isInverted()
    {
        return invert;
    }

    public void setInverted(boolean invert)
    {
        this.invert = invert;
    }

    public void tagICC(ICC_Profile profile)
    {
        this.profile = profile;
    }

    public boolean hasICCProfile()
    {
        return profile != null;
    }

    public ICC_Profile getICCProfile()
    {
        return profile;
    }

    public PdfDictionary getAdditional()
    {
        return additional;
    }

    public void setAdditional(PdfDictionary additional)
    {
        this.additional = additional;
    }

    public void simplifyColorspace()
    {
        if(additional == null)
            return;
        PdfArray value = additional.getAsArray(PdfName.COLORSPACE);
        if(value == null)
            return;
        PdfObject cs = simplifyColorspace(value);
        PdfObject newValue;
        if(cs.isName())
        {
            newValue = cs;
        } else
        {
            newValue = value;
            PdfName first = value.getAsName(0);
            if(PdfName.INDEXED.equals(first) && value.size() >= 2)
            {
                PdfArray second = value.getAsArray(1);
                if(second != null)
                    value.set(1, simplifyColorspace(second));
            }
        }
        additional.put(PdfName.COLORSPACE, newValue);
    }

    private PdfObject simplifyColorspace(PdfArray obj)
    {
        if(obj == null)
            return obj;
        PdfName first = obj.getAsName(0);
        if(PdfName.CALGRAY.equals(first))
            return PdfName.DEVICEGRAY;
        if(PdfName.CALRGB.equals(first))
            return PdfName.DEVICERGB;
        else
            return obj;
    }

    public boolean isMask()
    {
        return mask;
    }

    public void makeMask()
        throws DocumentException
    {
        if(!isMaskCandidate())
        {
            throw new DocumentException(MessageLocalization.getComposedMessage("this.image.can.not.be.an.image.mask", new Object[0]));
        } else
        {
            mask = true;
            return;
        }
    }

    public boolean isMaskCandidate()
    {
        if(type == 34 && bpc > 255)
            return true;
        else
            return colorspace == 1;
    }

    public Image getImageMask()
    {
        return imageMask;
    }

    public void setImageMask(Image mask)
        throws DocumentException
    {
        if(this.mask)
            throw new DocumentException(MessageLocalization.getComposedMessage("an.image.mask.cannot.contain.another.image.mask", new Object[0]));
        if(!mask.mask)
        {
            throw new DocumentException(MessageLocalization.getComposedMessage("the.image.mask.is.not.a.mask.did.you.do.makemask", new Object[0]));
        } else
        {
            imageMask = mask;
            smask = mask.bpc > 1 && mask.bpc <= 8;
            return;
        }
    }

    public boolean isSmask()
    {
        return smask;
    }

    public void setSmask(boolean smask)
    {
        this.smask = smask;
    }

    public int[] getTransparency()
    {
        return transparency;
    }

    public void setTransparency(int transparency[])
    {
        this.transparency = transparency;
    }

    public int getCompressionLevel()
    {
        return compressionLevel;
    }

    public void setCompressionLevel(int compressionLevel)
    {
        if(compressionLevel < 0 || compressionLevel > 9)
            this.compressionLevel = -1;
        else
            this.compressionLevel = compressionLevel;
    }

    public PdfObject getAccessibleAttribute(PdfName key)
    {
        if(accessibleAttributes != null)
            return (PdfObject)accessibleAttributes.get(key);
        else
            return null;
    }

    public void setAccessibleAttribute(PdfName key, PdfObject value)
    {
        if(accessibleAttributes == null)
            accessibleAttributes = new HashMap();
        accessibleAttributes.put(key, value);
    }

    public HashMap getAccessibleAttributes()
    {
        return accessibleAttributes;
    }

    public PdfName getRole()
    {
        return role;
    }

    public void setRole(PdfName role)
    {
        this.role = role;
    }

    public AccessibleElementId getId()
    {
        if(id == null)
            id = new AccessibleElementId();
        return id;
    }

    public void setId(AccessibleElementId id)
    {
        this.id = id;
    }

    public static Image getInstance(java.awt.Image image, Color color, boolean forceBW)
        throws BadElementException, IOException
    {
        if(image instanceof BufferedImage)
        {
            BufferedImage bi = (BufferedImage)image;
            if(bi.getType() == 12 && bi.getColorModel().getPixelSize() == 1)
                forceBW = true;
        }
        PixelGrabber pg = new PixelGrabber(image, 0, 0, -1, -1, true);
        try
        {
            pg.grabPixels();
        }
        catch(InterruptedException e)
        {
            throw new IOException(MessageLocalization.getComposedMessage("java.awt.image.interrupted.waiting.for.pixels", new Object[0]));
        }
        if((pg.getStatus() & 0x80) != 0)
            throw new IOException(MessageLocalization.getComposedMessage("java.awt.image.fetch.aborted.or.errored", new Object[0]));
        int w = pg.getWidth();
        int h = pg.getHeight();
        int pixels[] = (int[])(int[])pg.getPixels();
        int index;
        int size;
        if(forceBW)
        {
            int byteWidth = w / 8 + ((w & 7) == 0 ? 0 : 1);
            byte pixelsByte[] = new byte[byteWidth * h];
            index = 0;
            size = h * w;
            int transColor = 1;
            if(color != null)
                transColor = color.getRed() + color.getGreen() + color.getBlue() >= 384 ? 1 : 0;
            int transparency[] = null;
            int cbyte = 128;
            int wMarker = 0;
            int currByte = 0;
            if(color != null)
            {
                for(int j = 0; j < size; j++)
                {
                    int alpha = pixels[j] >> 24 & 0xff;
                    if(alpha < 250)
                    {
                        if(transColor == 1)
                            currByte |= cbyte;
                    } else
                    if((pixels[j] & 0x888) != 0)
                        currByte |= cbyte;
                    cbyte >>= 1;
                    if(cbyte == 0 || wMarker + 1 >= w)
                    {
                        pixelsByte[index++] = (byte)currByte;
                        cbyte = 128;
                        currByte = 0;
                    }
                    if(++wMarker >= w)
                        wMarker = 0;
                }

            } else
            {
                for(int j = 0; j < size; j++)
                {
                    if(transparency == null)
                    {
                        int alpha = pixels[j] >> 24 & 0xff;
                        if(alpha == 0)
                        {
                            transparency = new int[2];
                            transparency[0] = transparency[1] = (pixels[j] & 0x888) == 0 ? 0 : 255;
                        }
                    }
                    if((pixels[j] & 0x888) != 0)
                        currByte |= cbyte;
                    cbyte >>= 1;
                    if(cbyte == 0 || wMarker + 1 >= w)
                    {
                        pixelsByte[index++] = (byte)currByte;
                        cbyte = 128;
                        currByte = 0;
                    }
                    if(++wMarker >= w)
                        wMarker = 0;
                }

            }
            return getInstance(w, h, 1, 1, pixelsByte, transparency);
        }
        byte pixelsByte[] = new byte[w * h * 3];
        byte smask[] = null;
        index = 0;
        size = h * w;
        int red = 255;
        int green = 255;
        int blue = 255;
        if(color != null)
        {
            red = color.getRed();
            green = color.getGreen();
            blue = color.getBlue();
        }
        int transparency[] = null;
        if(color != null)
        {
            for(int j = 0; j < size; j++)
            {
                int alpha = pixels[j] >> 24 & 0xff;
                if(alpha < 250)
                {
                    pixelsByte[index++] = (byte)red;
                    pixelsByte[index++] = (byte)green;
                    pixelsByte[index++] = (byte)blue;
                } else
                {
                    pixelsByte[index++] = (byte)(pixels[j] >> 16 & 0xff);
                    pixelsByte[index++] = (byte)(pixels[j] >> 8 & 0xff);
                    pixelsByte[index++] = (byte)(pixels[j] & 0xff);
                }
            }

        } else
        {
            int transparentPixel = 0;
            smask = new byte[w * h];
            boolean shades = false;
            for(int j = 0; j < size; j++)
            {
                byte alpha = smask[j] = (byte)(pixels[j] >> 24 & 0xff);
                if(!shades)
                    if(alpha != 0 && alpha != -1)
                        shades = true;
                    else
                    if(transparency == null)
                    {
                        if(alpha == 0)
                        {
                            transparentPixel = pixels[j] & 0xffffff;
                            transparency = new int[6];
                            transparency[0] = transparency[1] = transparentPixel >> 16 & 0xff;
                            transparency[2] = transparency[3] = transparentPixel >> 8 & 0xff;
                            transparency[4] = transparency[5] = transparentPixel & 0xff;
                        }
                    } else
                    if((pixels[j] & 0xffffff) != transparentPixel)
                        shades = true;
                pixelsByte[index++] = (byte)(pixels[j] >> 16 & 0xff);
                pixelsByte[index++] = (byte)(pixels[j] >> 8 & 0xff);
                pixelsByte[index++] = (byte)(pixels[j] & 0xff);
            }

            if(shades)
                transparency = null;
            else
                smask = null;
        }
        Image img = getInstance(w, h, 3, 8, pixelsByte, transparency);
        if(smask != null)
        {
            Image sm = getInstance(w, h, 1, 8, smask);
            try
            {
                sm.makeMask();
                img.setImageMask(sm);
            }
            catch(DocumentException de)
            {
                throw new ExceptionConverter(de);
            }
        }
        return img;
    }

    public static Image getInstance(java.awt.Image image, Color color)
        throws BadElementException, IOException
    {
        return getInstance(image, color, false);
    }

    public static Image getInstance(PdfWriter writer, java.awt.Image awtImage, float quality)
        throws BadElementException, IOException
    {
        return getInstance(new PdfContentByte(writer), awtImage, quality);
    }

    public static Image getInstance(PdfContentByte cb, java.awt.Image awtImage, float quality)
        throws BadElementException, IOException
    {
        PixelGrabber pg = new PixelGrabber(awtImage, 0, 0, -1, -1, true);
        try
        {
            pg.grabPixels();
        }
        catch(InterruptedException e)
        {
            throw new IOException(MessageLocalization.getComposedMessage("java.awt.image.interrupted.waiting.for.pixels", new Object[0]));
        }
        if((pg.getStatus() & 0x80) != 0)
        {
            throw new IOException(MessageLocalization.getComposedMessage("java.awt.image.fetch.aborted.or.errored", new Object[0]));
        } else
        {
            int w = pg.getWidth();
            int h = pg.getHeight();
            PdfTemplate tp = cb.createTemplate(w, h);
            PdfGraphics2D g2d = new PdfGraphics2D(tp, w, h, null, false, true, quality);
            g2d.drawImage(awtImage, 0, 0, null);
            g2d.dispose();
            return getInstance(tp);
        }
    }

    public static final int DEFAULT = 0;
    public static final int RIGHT = 2;
    public static final int LEFT = 0;
    public static final int MIDDLE = 1;
    public static final int TEXTWRAP = 4;
    public static final int UNDERLYING = 8;
    public static final int AX = 0;
    public static final int AY = 1;
    public static final int BX = 2;
    public static final int BY = 3;
    public static final int CX = 4;
    public static final int CY = 5;
    public static final int DX = 6;
    public static final int DY = 7;
    public static final int ORIGINAL_NONE = 0;
    public static final int ORIGINAL_JPEG = 1;
    public static final int ORIGINAL_PNG = 2;
    public static final int ORIGINAL_GIF = 3;
    public static final int ORIGINAL_BMP = 4;
    public static final int ORIGINAL_TIFF = 5;
    public static final int ORIGINAL_WMF = 6;
    public static final int ORIGINAL_PS = 7;
    public static final int ORIGINAL_JPEG2000 = 8;
    public static final int ORIGINAL_JBIG2 = 9;
    protected int type;
    protected URL url;
    protected byte rawData[];
    protected int bpc;
    protected PdfTemplate template[];
    protected int alignment;
    protected String alt;
    protected float absoluteX;
    protected float absoluteY;
    protected float plainWidth;
    protected float plainHeight;
    protected float scaledWidth;
    protected float scaledHeight;
    protected int compressionLevel;
    protected Long mySerialId;
    protected PdfName role;
    protected HashMap accessibleAttributes;
    private AccessibleElementId id;
    private PdfIndirectReference directReference;
    static long serialId = 0L;
    protected float rotationRadians;
    private float initialRotation;
    protected float indentationLeft;
    protected float indentationRight;
    protected float spacingBefore;
    protected float spacingAfter;
    private float widthPercentage;
    protected boolean scaleToFitLineWhenOverflow;
    protected boolean scaleToFitHeight;
    protected Annotation annotation;
    protected PdfOCG layer;
    protected boolean interpolation;
    protected int originalType;
    protected byte originalData[];
    protected boolean deflated;
    protected int dpiX;
    protected int dpiY;
    private float XYRatio;
    protected int colorspace;
    protected int colortransform;
    protected boolean invert;
    protected ICC_Profile profile;
    private PdfDictionary additional;
    protected boolean mask;
    protected Image imageMask;
    private boolean smask;
    protected int transparency[];

}
