// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   Ntlm.java

package com.sun.mail.auth;

import com.sun.mail.util.*;
import java.io.UnsupportedEncodingException;
import java.security.GeneralSecurityException;
import java.security.NoSuchAlgorithmException;
import java.util.Locale;
import java.util.logging.Level;
import javax.crypto.*;
import javax.crypto.spec.DESKeySpec;

// Referenced classes of package com.sun.mail.auth:
//            MD4

public class Ntlm
{

    private void init0()
    {
        type1 = new byte[256];
        type3 = new byte[256];
        System.arraycopy(new byte[] {
            78, 84, 76, 77, 83, 83, 80, 0, 1
        }, 0, type1, 0, 9);
        type1[12] = 3;
        type1[13] = -78;
        type1[28] = 32;
        System.arraycopy(new byte[] {
            78, 84, 76, 77, 83, 83, 80, 0, 3
        }, 0, type3, 0, 9);
        type3[12] = 24;
        type3[14] = 24;
        type3[20] = 24;
        type3[22] = 24;
        type3[32] = 64;
        type3[60] = 1;
        type3[61] = -126;
        try
        {
            fac = SecretKeyFactory.getInstance("DES");
            cipher = Cipher.getInstance("DES/ECB/NoPadding");
            md4 = new MD4();
        }
        catch(NoSuchPaddingException e)
        {
            if(!$assertionsDisabled)
                throw new AssertionError();
        }
        catch(NoSuchAlgorithmException e)
        {
            if(!$assertionsDisabled)
                throw new AssertionError();
        }
    }

    public Ntlm(String ntdomain, String hostname, String username, String password, MailLogger logger)
    {
        int i = hostname.indexOf('.');
        if(i != -1)
            hostname = hostname.substring(0, i);
        i = username.indexOf('\\');
        if(i != -1)
        {
            ntdomain = username.substring(0, i).toUpperCase();
            username = username.substring(i + 1);
        } else
        if(ntdomain == null)
            ntdomain = "";
        this.ntdomain = ntdomain;
        this.hostname = hostname;
        this.username = username;
        this.password = password;
        this.logger = logger.getLogger(getClass(), "DEBUG NTLM");
        init0();
    }

    private void copybytes(byte dest[], int destpos, String src, String enc)
    {
        try
        {
            byte x[] = src.getBytes(enc);
            System.arraycopy(x, 0, dest, destpos, x.length);
        }
        catch(UnsupportedEncodingException e)
        {
            if(!$assertionsDisabled)
                throw new AssertionError();
        }
    }

    public String generateType1Msg(int flags)
    {
        int dlen = ntdomain.length();
        type1[16] = (byte)(dlen % 256);
        type1[17] = (byte)(dlen / 256);
        type1[18] = type1[16];
        type1[19] = type1[17];
        if(dlen == 0)
            type1[13] &= 0xef;
        int hlen = hostname.length();
        type1[24] = (byte)(hlen % 256);
        type1[25] = (byte)(hlen / 256);
        type1[26] = type1[24];
        type1[27] = type1[25];
        copybytes(type1, 32, hostname, "iso-8859-1");
        copybytes(type1, hlen + 32, ntdomain, "iso-8859-1");
        type1[20] = (byte)((hlen + 32) % 256);
        type1[21] = (byte)((hlen + 32) / 256);
        byte msg[] = new byte[32 + hlen + dlen];
        System.arraycopy(type1, 0, msg, 0, 32 + hlen + dlen);
        if(logger.isLoggable(Level.FINE))
            logger.fine((new StringBuilder()).append("type 1 message: ").append(toHex(msg)).toString());
        String result = null;
        try
        {
            result = new String(BASE64EncoderStream.encode(msg), "iso-8859-1");
        }
        catch(UnsupportedEncodingException e)
        {
            if(!$assertionsDisabled)
                throw new AssertionError();
        }
        return result;
    }

    private byte[] makeDesKey(byte input[], int off)
    {
        int in[] = new int[input.length];
        for(int i = 0; i < in.length; i++)
            in[i] = input[i] >= 0 ? ((int) (input[i])) : input[i] + 256;

        byte out[] = new byte[8];
        out[0] = (byte)in[off + 0];
        out[1] = (byte)(in[off + 0] << 7 & 0xff | in[off + 1] >> 1);
        out[2] = (byte)(in[off + 1] << 6 & 0xff | in[off + 2] >> 2);
        out[3] = (byte)(in[off + 2] << 5 & 0xff | in[off + 3] >> 3);
        out[4] = (byte)(in[off + 3] << 4 & 0xff | in[off + 4] >> 4);
        out[5] = (byte)(in[off + 4] << 3 & 0xff | in[off + 5] >> 5);
        out[6] = (byte)(in[off + 5] << 2 & 0xff | in[off + 6] >> 6);
        out[7] = (byte)(in[off + 6] << 1 & 0xff);
        return out;
    }

    private byte[] calcLMHash()
        throws GeneralSecurityException
    {
        byte magic[] = {
            75, 71, 83, 33, 64, 35, 36, 37
        };
        byte pwb[] = null;
        try
        {
            pwb = password.toUpperCase(Locale.ENGLISH).getBytes("iso-8859-1");
        }
        catch(UnsupportedEncodingException ex)
        {
            if(!$assertionsDisabled)
                throw new AssertionError();
        }
        byte pwb1[] = new byte[14];
        int len = password.length();
        if(len > 14)
            len = 14;
        System.arraycopy(pwb, 0, pwb1, 0, len);
        DESKeySpec dks1 = new DESKeySpec(makeDesKey(pwb1, 0));
        DESKeySpec dks2 = new DESKeySpec(makeDesKey(pwb1, 7));
        javax.crypto.SecretKey key1 = fac.generateSecret(dks1);
        javax.crypto.SecretKey key2 = fac.generateSecret(dks2);
        cipher.init(1, key1);
        byte out1[] = cipher.doFinal(magic, 0, 8);
        cipher.init(1, key2);
        byte out2[] = cipher.doFinal(magic, 0, 8);
        byte result[] = new byte[21];
        System.arraycopy(out1, 0, result, 0, 8);
        System.arraycopy(out2, 0, result, 8, 8);
        return result;
    }

    private byte[] calcNTHash()
        throws GeneralSecurityException
    {
        byte pw[] = null;
        try
        {
            pw = password.getBytes("UnicodeLittleUnmarked");
        }
        catch(UnsupportedEncodingException e)
        {
            if(!$assertionsDisabled)
                throw new AssertionError();
        }
        byte out[] = md4.digest(pw);
        byte result[] = new byte[21];
        System.arraycopy(out, 0, result, 0, 16);
        return result;
    }

    private byte[] calcResponse(byte key[], byte text[])
        throws GeneralSecurityException
    {
        if(!$assertionsDisabled && key.length != 21)
        {
            throw new AssertionError();
        } else
        {
            DESKeySpec dks1 = new DESKeySpec(makeDesKey(key, 0));
            DESKeySpec dks2 = new DESKeySpec(makeDesKey(key, 7));
            DESKeySpec dks3 = new DESKeySpec(makeDesKey(key, 14));
            javax.crypto.SecretKey key1 = fac.generateSecret(dks1);
            javax.crypto.SecretKey key2 = fac.generateSecret(dks2);
            javax.crypto.SecretKey key3 = fac.generateSecret(dks3);
            cipher.init(1, key1);
            byte out1[] = cipher.doFinal(text, 0, 8);
            cipher.init(1, key2);
            byte out2[] = cipher.doFinal(text, 0, 8);
            cipher.init(1, key3);
            byte out3[] = cipher.doFinal(text, 0, 8);
            byte result[] = new byte[24];
            System.arraycopy(out1, 0, result, 0, 8);
            System.arraycopy(out2, 0, result, 8, 8);
            System.arraycopy(out3, 0, result, 16, 8);
            return result;
        }
    }

    public String generateType3Msg(String challenge)
    {
        try
        {
            byte type2[] = null;
            try
            {
                type2 = BASE64DecoderStream.decode(challenge.getBytes("us-ascii"));
            }
            catch(UnsupportedEncodingException ex)
            {
                if(!$assertionsDisabled)
                    throw new AssertionError();
            }
            byte nonce[] = new byte[8];
            System.arraycopy(type2, 24, nonce, 0, 8);
            int ulen = username.length() * 2;
            type3[36] = type3[38] = (byte)(ulen % 256);
            type3[37] = type3[39] = (byte)(ulen / 256);
            int dlen = ntdomain.length() * 2;
            type3[28] = type3[30] = (byte)(dlen % 256);
            type3[29] = type3[31] = (byte)(dlen / 256);
            int hlen = hostname.length() * 2;
            type3[44] = type3[46] = (byte)(hlen % 256);
            type3[45] = type3[47] = (byte)(hlen / 256);
            int l = 64;
            copybytes(type3, l, ntdomain, "UnicodeLittleUnmarked");
            type3[32] = (byte)(l % 256);
            type3[33] = (byte)(l / 256);
            l += dlen;
            copybytes(type3, l, username, "UnicodeLittleUnmarked");
            type3[40] = (byte)(l % 256);
            type3[41] = (byte)(l / 256);
            l += ulen;
            copybytes(type3, l, hostname, "UnicodeLittleUnmarked");
            type3[48] = (byte)(l % 256);
            type3[49] = (byte)(l / 256);
            l += hlen;
            byte lmhash[] = calcLMHash();
            byte lmresponse[] = calcResponse(lmhash, nonce);
            byte nthash[] = calcNTHash();
            byte ntresponse[] = calcResponse(nthash, nonce);
            System.arraycopy(lmresponse, 0, type3, l, 24);
            type3[16] = (byte)(l % 256);
            type3[17] = (byte)(l / 256);
            l += 24;
            System.arraycopy(ntresponse, 0, type3, l, 24);
            type3[24] = (byte)(l % 256);
            type3[25] = (byte)(l / 256);
            l += 24;
            type3[56] = (byte)(l % 256);
            type3[57] = (byte)(l / 256);
            byte msg[] = new byte[l];
            System.arraycopy(type3, 0, msg, 0, l);
            if(logger.isLoggable(Level.FINE))
                logger.fine((new StringBuilder()).append("type 3 message: ").append(toHex(msg)).toString());
            String result = null;
            try
            {
                result = new String(BASE64EncoderStream.encode(msg), "iso-8859-1");
            }
            catch(UnsupportedEncodingException e)
            {
                if(!$assertionsDisabled)
                    throw new AssertionError();
            }
            return result;
        }
        catch(GeneralSecurityException ex)
        {
            logger.log(Level.FINE, "GeneralSecurityException", ex);
        }
        return "";
    }

    private static String toHex(byte b[])
    {
        StringBuffer sb = new StringBuffer(b.length * 3);
        for(int i = 0; i < b.length; i++)
            sb.append(hex[b[i] >> 4 & 0xf]).append(hex[b[i] & 0xf]).append(' ');

        return sb.toString();
    }

    private byte type1[];
    private byte type3[];
    private SecretKeyFactory fac;
    private Cipher cipher;
    private MD4 md4;
    private String hostname;
    private String ntdomain;
    private String username;
    private String password;
    private MailLogger logger;
    private static char hex[] = {
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
        'A', 'B', 'C', 'D', 'E', 'F'
    };
    static final boolean $assertionsDisabled = !com/sun/mail/auth/Ntlm.desiredAssertionStatus();

}
