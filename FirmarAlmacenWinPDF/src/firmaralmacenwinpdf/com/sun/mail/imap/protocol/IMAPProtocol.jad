// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   IMAPProtocol.java

package com.sun.mail.imap.protocol;

import com.sun.mail.auth.Ntlm;
import com.sun.mail.iap.*;
import com.sun.mail.imap.*;
import com.sun.mail.util.*;
import java.io.*;
import java.lang.reflect.Constructor;
import java.util.*;
import java.util.logging.Level;
import javax.mail.Flags;
import javax.mail.Quota;
import javax.mail.internet.MimeUtility;
import javax.mail.search.SearchException;
import javax.mail.search.SearchTerm;

// Referenced classes of package com.sun.mail.imap.protocol:
//            IMAPResponse, FetchResponse, SaslAuthenticator, MailboxInfo, 
//            Status, ListInfo, BODYSTRUCTURE, BODY, 
//            RFC822DATA, UID, SearchSequence, Namespaces, 
//            FetchItem, BASE64MailboxEncoder, INTERNALDATE, UIDSet, 
//            MessageSet

public class IMAPProtocol extends Protocol
{

    public IMAPProtocol(String name, String host, int port, Properties props, boolean isSSL, MailLogger logger)
        throws IOException, ProtocolException
    {
        super(host, port, props, (new StringBuilder()).append("mail.").append(name).toString(), isSSL, logger);
        connected = false;
        rev1 = false;
        noauthdebug = true;
        this.name = name;
        noauthdebug = !PropUtil.getBooleanProperty(props, "mail.debug.auth", false);
        if(capabilities == null)
            capability();
        if(hasCapability("IMAP4rev1"))
            rev1 = true;
        searchCharsets = new String[2];
        searchCharsets[0] = "UTF-8";
        searchCharsets[1] = MimeUtility.mimeCharset(MimeUtility.getDefaultJavaCharset());
        connected = true;
        if(!connected)
            disconnect();
        break MISSING_BLOCK_LABEL_159;
        Exception exception;
        exception;
        if(!connected)
            disconnect();
        throw exception;
    }

    public FetchItem[] getFetchItems()
    {
        return fetchItems;
    }

    public void capability()
        throws ProtocolException
    {
        Response r[] = command("CAPABILITY", null);
        if(!r[r.length - 1].isOK())
            throw new ProtocolException(r[r.length - 1].toString());
        capabilities = new HashMap(10);
        authmechs = new ArrayList(5);
        int i = 0;
        for(int len = r.length; i < len; i++)
        {
            if(!(r[i] instanceof IMAPResponse))
                continue;
            IMAPResponse ir = (IMAPResponse)r[i];
            if(ir.keyEquals("CAPABILITY"))
                parseCapabilities(ir);
        }

    }

    protected void setCapabilities(Response r)
    {
        byte b;
        while((b = r.readByte()) > 0 && b != 91) ;
        if(b == 0)
            return;
        String s = r.readAtom();
        if(!s.equalsIgnoreCase("CAPABILITY"))
        {
            return;
        } else
        {
            capabilities = new HashMap(10);
            authmechs = new ArrayList(5);
            parseCapabilities(r);
            return;
        }
    }

    protected void parseCapabilities(Response r)
    {
        do
        {
            String s;
            if((s = r.readAtom(']')) == null)
                break;
            if(s.length() == 0)
            {
                if(r.peekByte() == 93)
                    break;
                r.skipToken();
            } else
            {
                capabilities.put(s.toUpperCase(Locale.ENGLISH), s);
                if(s.regionMatches(true, 0, "AUTH=", 0, 5))
                {
                    authmechs.add(s.substring(5));
                    if(logger.isLoggable(Level.FINE))
                        logger.fine((new StringBuilder()).append("AUTH: ").append(s.substring(5)).toString());
                }
            }
        } while(true);
    }

    protected void processGreeting(Response r)
        throws ProtocolException
    {
        super.processGreeting(r);
        if(r.isOK())
        {
            setCapabilities(r);
            return;
        }
        IMAPResponse ir = (IMAPResponse)r;
        if(ir.keyEquals("PREAUTH"))
        {
            authenticated = true;
            setCapabilities(r);
        } else
        {
            throw new ConnectionException(this, r);
        }
    }

    public boolean isAuthenticated()
    {
        return authenticated;
    }

    public boolean isREV1()
    {
        return rev1;
    }

    protected boolean supportsNonSyncLiterals()
    {
        return hasCapability("LITERAL+");
    }

    public Response readResponse()
        throws IOException, ProtocolException
    {
        IMAPResponse r = new IMAPResponse(this);
        if(r.keyEquals("FETCH"))
            r = new FetchResponse(r, getFetchItems());
        return r;
    }

    public boolean hasCapability(String c)
    {
        if(c.endsWith("*"))
        {
            c = c.substring(0, c.length() - 1).toUpperCase(Locale.ENGLISH);
            for(Iterator it = capabilities.keySet().iterator(); it.hasNext();)
                if(((String)it.next()).startsWith(c))
                    return true;

            return false;
        } else
        {
            return capabilities.containsKey(c.toUpperCase(Locale.ENGLISH));
        }
    }

    public Map getCapabilities()
    {
        return capabilities;
    }

    public void disconnect()
    {
        super.disconnect();
        authenticated = false;
    }

    public void noop()
        throws ProtocolException
    {
        logger.fine("IMAPProtocol noop");
        simpleCommand("NOOP", null);
    }

    public void logout()
        throws ProtocolException
    {
        Response r[] = command("LOGOUT", null);
        authenticated = false;
        notifyResponseHandlers(r);
        disconnect();
        break MISSING_BLOCK_LABEL_32;
        Exception exception;
        exception;
        disconnect();
        throw exception;
    }

    public void login(String u, String p)
        throws ProtocolException
    {
        Argument args;
        Response r[];
        args = new Argument();
        args.writeString(u);
        args.writeString(p);
        r = null;
        if(noauthdebug && isTracing())
        {
            logger.fine("LOGIN command trace suppressed");
            suspendTracing();
        }
        r = command("LOGIN", args);
        resumeTracing();
        break MISSING_BLOCK_LABEL_73;
        Exception exception;
        exception;
        resumeTracing();
        throw exception;
        notifyResponseHandlers(r);
        if(noauthdebug && isTracing())
            logger.fine((new StringBuilder()).append("LOGIN command result: ").append(r[r.length - 1]).toString());
        handleResult(r[r.length - 1]);
        setCapabilities(r[r.length - 1]);
        authenticated = true;
        return;
    }

    public synchronized void authlogin(String u, String p)
        throws ProtocolException
    {
        Vector v;
        String tag;
        Response r;
        boolean done;
        v = new Vector();
        tag = null;
        r = null;
        done = false;
        if(noauthdebug && isTracing())
        {
            logger.fine("AUTHENTICATE LOGIN command trace suppressed");
            suspendTracing();
        }
        try
        {
            tag = writeCommand("AUTHENTICATE LOGIN", null);
        }
        catch(Exception ex)
        {
            r = Response.byeResponse(ex);
            done = true;
        }
        OutputStream os = getOutputStream();
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        OutputStream b64os = new BASE64EncoderStream(bos, 0x7fffffff);
        boolean first = true;
        while(!done) 
            try
            {
                r = readResponse();
                if(r.isContinuation())
                {
                    String s;
                    if(first)
                    {
                        s = u;
                        first = false;
                    } else
                    {
                        s = p;
                    }
                    b64os.write(ASCIIUtility.getBytes(s));
                    b64os.flush();
                    bos.write(CRLF);
                    os.write(bos.toByteArray());
                    os.flush();
                    bos.reset();
                } else
                if(r.isTagged() && r.getTag().equals(tag))
                    done = true;
                else
                if(r.isBYE())
                    done = true;
                else
                    v.addElement(r);
            }
            catch(Exception ioex)
            {
                r = Response.byeResponse(ioex);
                done = true;
            }
        resumeTracing();
        break MISSING_BLOCK_LABEL_262;
        Exception exception;
        exception;
        resumeTracing();
        throw exception;
        Response responses[] = new Response[v.size()];
        v.copyInto(responses);
        notifyResponseHandlers(responses);
        if(noauthdebug && isTracing())
            logger.fine((new StringBuilder()).append("AUTHENTICATE LOGIN command result: ").append(r).toString());
        handleResult(r);
        setCapabilities(r);
        authenticated = true;
        return;
    }

    public synchronized void authplain(String authzid, String u, String p)
        throws ProtocolException
    {
        Vector v;
        String tag;
        Response r;
        boolean done;
        v = new Vector();
        tag = null;
        r = null;
        done = false;
        if(noauthdebug && isTracing())
        {
            logger.fine("AUTHENTICATE PLAIN command trace suppressed");
            suspendTracing();
        }
        try
        {
            tag = writeCommand("AUTHENTICATE PLAIN", null);
        }
        catch(Exception ex)
        {
            r = Response.byeResponse(ex);
            done = true;
        }
        OutputStream os = getOutputStream();
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        OutputStream b64os = new BASE64EncoderStream(bos, 0x7fffffff);
        while(!done) 
            try
            {
                r = readResponse();
                if(r.isContinuation())
                {
                    String nullByte = "\0";
                    String s = (new StringBuilder()).append(authzid != null ? authzid : "").append("\0").append(u).append("\0").append(p).toString();
                    b64os.write(ASCIIUtility.getBytes(s));
                    b64os.flush();
                    bos.write(CRLF);
                    os.write(bos.toByteArray());
                    os.flush();
                    bos.reset();
                } else
                if(r.isTagged() && r.getTag().equals(tag))
                    done = true;
                else
                if(r.isBYE())
                    done = true;
                else
                    v.addElement(r);
            }
            catch(Exception ioex)
            {
                r = Response.byeResponse(ioex);
                done = true;
            }
        resumeTracing();
        break MISSING_BLOCK_LABEL_291;
        Exception exception;
        exception;
        resumeTracing();
        throw exception;
        Response responses[] = new Response[v.size()];
        v.copyInto(responses);
        notifyResponseHandlers(responses);
        if(noauthdebug && isTracing())
            logger.fine((new StringBuilder()).append("AUTHENTICATE PLAIN command result: ").append(r).toString());
        handleResult(r);
        setCapabilities(r);
        authenticated = true;
        return;
    }

    public synchronized void authntlm(String authzid, String u, String p)
        throws ProtocolException
    {
        Vector v;
        String tag;
        Response r;
        boolean done;
        int flags;
        Ntlm ntlm;
        v = new Vector();
        tag = null;
        r = null;
        done = false;
        String type1Msg = null;
        flags = PropUtil.getIntProperty(props, (new StringBuilder()).append("mail.").append(name).append(".auth.ntlm.flags").toString(), 0);
        String domain = props.getProperty((new StringBuilder()).append("mail.").append(name).append(".auth.ntlm.domain").toString(), "");
        ntlm = new Ntlm(domain, getLocalHost(), u, p, logger);
        if(noauthdebug && isTracing())
        {
            logger.fine("AUTHENTICATE NTLM command trace suppressed");
            suspendTracing();
        }
        try
        {
            tag = writeCommand("AUTHENTICATE NTLM", null);
        }
        catch(Exception ex)
        {
            r = Response.byeResponse(ex);
            done = true;
        }
        OutputStream os = getOutputStream();
        boolean first = true;
        while(!done) 
            try
            {
                r = readResponse();
                if(r.isContinuation())
                {
                    String s;
                    if(first)
                    {
                        s = ntlm.generateType1Msg(flags);
                        first = false;
                    } else
                    {
                        s = ntlm.generateType3Msg(r.getRest());
                    }
                    os.write(ASCIIUtility.getBytes(s));
                    os.write(CRLF);
                    os.flush();
                } else
                if(r.isTagged() && r.getTag().equals(tag))
                    done = true;
                else
                if(r.isBYE())
                    done = true;
                else
                    v.addElement(r);
            }
            catch(Exception ioex)
            {
                r = Response.byeResponse(ioex);
                done = true;
            }
        resumeTracing();
        break MISSING_BLOCK_LABEL_336;
        Exception exception;
        exception;
        resumeTracing();
        throw exception;
        Response responses[] = new Response[v.size()];
        v.copyInto(responses);
        notifyResponseHandlers(responses);
        if(noauthdebug && isTracing())
            logger.fine((new StringBuilder()).append("AUTHENTICATE NTLM command result: ").append(r).toString());
        handleResult(r);
        setCapabilities(r);
        authenticated = true;
        return;
    }

    public void sasllogin(String allowed[], String realm, String authzid, String u, String p)
        throws ProtocolException
    {
        String mechs[];
        if(saslAuthenticator == null)
            try
            {
                Class sac = Class.forName("com.sun.mail.imap.protocol.IMAPSaslAuthenticator");
                Constructor c = sac.getConstructor(new Class[] {
                    com/sun/mail/imap/protocol/IMAPProtocol, java/lang/String, java/util/Properties, com/sun/mail/util/MailLogger, java/lang/String
                });
                saslAuthenticator = (SaslAuthenticator)c.newInstance(new Object[] {
                    this, name, props, logger, host
                });
            }
            catch(Exception ex)
            {
                logger.log(Level.FINE, "Can't load SASL authenticator", ex);
                return;
            }
        List v;
        if(allowed != null && allowed.length > 0)
        {
            v = new ArrayList(allowed.length);
            for(int i = 0; i < allowed.length; i++)
                if(authmechs.contains(allowed[i]))
                    v.add(allowed[i]);

        } else
        {
            v = authmechs;
        }
        mechs = (String[])(String[])v.toArray(new String[v.size()]);
        if(noauthdebug && isTracing())
        {
            logger.fine("SASL authentication command trace suppressed");
            suspendTracing();
        }
        if(saslAuthenticator.authenticate(mechs, realm, authzid, u, p))
        {
            if(noauthdebug && isTracing())
                logger.fine("SASL authentication succeeded");
            authenticated = true;
        } else
        if(noauthdebug && isTracing())
            logger.fine("SASL authentication failed");
        resumeTracing();
        break MISSING_BLOCK_LABEL_338;
        Exception exception;
        exception;
        resumeTracing();
        throw exception;
    }

    OutputStream getIMAPOutputStream()
    {
        return getOutputStream();
    }

    public void proxyauth(String u)
        throws ProtocolException
    {
        Argument args = new Argument();
        args.writeString(u);
        simpleCommand("PROXYAUTH", args);
    }

    public void id(String guid)
        throws ProtocolException
    {
        simpleCommand((new StringBuilder()).append("ID (\"GUID\" \"").append(guid).append("\")").toString(), null);
    }

    public void startTLS()
        throws ProtocolException
    {
        try
        {
            super.startTLS("STARTTLS");
        }
        catch(ProtocolException pex)
        {
            logger.log(Level.FINE, "STARTTLS ProtocolException", pex);
            throw pex;
        }
        catch(Exception ex)
        {
            logger.log(Level.FINE, "STARTTLS Exception", ex);
            Response r[] = {
                Response.byeResponse(ex)
            };
            notifyResponseHandlers(r);
            disconnect();
            throw new ProtocolException("STARTTLS failure", ex);
        }
    }

    public MailboxInfo select(String mbox)
        throws ProtocolException
    {
        mbox = BASE64MailboxEncoder.encode(mbox);
        Argument args = new Argument();
        args.writeString(mbox);
        Response r[] = command("SELECT", args);
        MailboxInfo minfo = new MailboxInfo(r);
        notifyResponseHandlers(r);
        Response response = r[r.length - 1];
        if(response.isOK())
            if(response.toString().indexOf("READ-ONLY") != -1)
                minfo.mode = 1;
            else
                minfo.mode = 2;
        handleResult(response);
        return minfo;
    }

    public MailboxInfo examine(String mbox)
        throws ProtocolException
    {
        mbox = BASE64MailboxEncoder.encode(mbox);
        Argument args = new Argument();
        args.writeString(mbox);
        Response r[] = command("EXAMINE", args);
        MailboxInfo minfo = new MailboxInfo(r);
        minfo.mode = 1;
        notifyResponseHandlers(r);
        handleResult(r[r.length - 1]);
        return minfo;
    }

    public void unselect()
        throws ProtocolException
    {
        if(!hasCapability("UNSELECT"))
        {
            throw new BadCommandException("UNSELECT not supported");
        } else
        {
            simpleCommand("UNSELECT", null);
            return;
        }
    }

    public Status status(String mbox, String items[])
        throws ProtocolException
    {
        if(!isREV1() && !hasCapability("IMAP4SUNVERSION"))
            throw new BadCommandException("STATUS not supported");
        mbox = BASE64MailboxEncoder.encode(mbox);
        Argument args = new Argument();
        args.writeString(mbox);
        Argument itemArgs = new Argument();
        if(items == null)
            items = Status.standardItems;
        int i = 0;
        for(int len = items.length; i < len; i++)
            itemArgs.writeAtom(items[i]);

        args.writeArgument(itemArgs);
        Response r[] = command("STATUS", args);
        Status status = null;
        Response response = r[r.length - 1];
        if(response.isOK())
        {
            int i = 0;
            for(int len = r.length; i < len; i++)
            {
                if(!(r[i] instanceof IMAPResponse))
                    continue;
                IMAPResponse ir = (IMAPResponse)r[i];
                if(!ir.keyEquals("STATUS"))
                    continue;
                if(status == null)
                    status = new Status(ir);
                else
                    Status.add(status, new Status(ir));
                r[i] = null;
            }

        }
        notifyResponseHandlers(r);
        handleResult(response);
        return status;
    }

    public void create(String mbox)
        throws ProtocolException
    {
        mbox = BASE64MailboxEncoder.encode(mbox);
        Argument args = new Argument();
        args.writeString(mbox);
        simpleCommand("CREATE", args);
    }

    public void delete(String mbox)
        throws ProtocolException
    {
        mbox = BASE64MailboxEncoder.encode(mbox);
        Argument args = new Argument();
        args.writeString(mbox);
        simpleCommand("DELETE", args);
    }

    public void rename(String o, String n)
        throws ProtocolException
    {
        o = BASE64MailboxEncoder.encode(o);
        n = BASE64MailboxEncoder.encode(n);
        Argument args = new Argument();
        args.writeString(o);
        args.writeString(n);
        simpleCommand("RENAME", args);
    }

    public void subscribe(String mbox)
        throws ProtocolException
    {
        Argument args = new Argument();
        mbox = BASE64MailboxEncoder.encode(mbox);
        args.writeString(mbox);
        simpleCommand("SUBSCRIBE", args);
    }

    public void unsubscribe(String mbox)
        throws ProtocolException
    {
        Argument args = new Argument();
        mbox = BASE64MailboxEncoder.encode(mbox);
        args.writeString(mbox);
        simpleCommand("UNSUBSCRIBE", args);
    }

    public ListInfo[] list(String ref, String pattern)
        throws ProtocolException
    {
        return doList("LIST", ref, pattern);
    }

    public ListInfo[] lsub(String ref, String pattern)
        throws ProtocolException
    {
        return doList("LSUB", ref, pattern);
    }

    protected ListInfo[] doList(String cmd, String ref, String pat)
        throws ProtocolException
    {
        ref = BASE64MailboxEncoder.encode(ref);
        pat = BASE64MailboxEncoder.encode(pat);
        Argument args = new Argument();
        args.writeString(ref);
        args.writeString(pat);
        Response r[] = command(cmd, args);
        ListInfo linfo[] = null;
        Response response = r[r.length - 1];
        if(response.isOK())
        {
            Vector v = new Vector(1);
            int i = 0;
            for(int len = r.length; i < len; i++)
            {
                if(!(r[i] instanceof IMAPResponse))
                    continue;
                IMAPResponse ir = (IMAPResponse)r[i];
                if(ir.keyEquals(cmd))
                {
                    v.addElement(new ListInfo(ir));
                    r[i] = null;
                }
            }

            if(v.size() > 0)
            {
                linfo = new ListInfo[v.size()];
                v.copyInto(linfo);
            }
        }
        notifyResponseHandlers(r);
        handleResult(response);
        return linfo;
    }

    public void append(String mbox, Flags f, Date d, Literal data)
        throws ProtocolException
    {
        appenduid(mbox, f, d, data, false);
    }

    public AppendUID appenduid(String mbox, Flags f, Date d, Literal data)
        throws ProtocolException
    {
        return appenduid(mbox, f, d, data, true);
    }

    public AppendUID appenduid(String mbox, Flags f, Date d, Literal data, boolean uid)
        throws ProtocolException
    {
        mbox = BASE64MailboxEncoder.encode(mbox);
        Argument args = new Argument();
        args.writeString(mbox);
        if(f != null)
        {
            if(f.contains(javax.mail.Flags.Flag.RECENT))
            {
                f = new Flags(f);
                f.remove(javax.mail.Flags.Flag.RECENT);
            }
            args.writeAtom(createFlagList(f));
        }
        if(d != null)
            args.writeString(INTERNALDATE.format(d));
        args.writeBytes(data);
        Response r[] = command("APPEND", args);
        notifyResponseHandlers(r);
        handleResult(r[r.length - 1]);
        if(uid)
            return getAppendUID(r[r.length - 1]);
        else
            return null;
    }

    private AppendUID getAppendUID(Response r)
    {
        if(!r.isOK())
            return null;
        byte b;
        while((b = r.readByte()) > 0 && b != 91) ;
        if(b == 0)
            return null;
        String s = r.readAtom();
        if(!s.equalsIgnoreCase("APPENDUID"))
        {
            return null;
        } else
        {
            long uidvalidity = r.readLong();
            long uid = r.readLong();
            return new AppendUID(uidvalidity, uid);
        }
    }

    public void check()
        throws ProtocolException
    {
        simpleCommand("CHECK", null);
    }

    public void close()
        throws ProtocolException
    {
        simpleCommand("CLOSE", null);
    }

    public void expunge()
        throws ProtocolException
    {
        simpleCommand("EXPUNGE", null);
    }

    public void uidexpunge(UIDSet set[])
        throws ProtocolException
    {
        if(!hasCapability("UIDPLUS"))
        {
            throw new BadCommandException("UID EXPUNGE not supported");
        } else
        {
            simpleCommand((new StringBuilder()).append("UID EXPUNGE ").append(UIDSet.toString(set)).toString(), null);
            return;
        }
    }

    public BODYSTRUCTURE fetchBodyStructure(int msgno)
        throws ProtocolException
    {
        Response r[] = fetch(msgno, "BODYSTRUCTURE");
        notifyResponseHandlers(r);
        Response response = r[r.length - 1];
        if(response.isOK())
            return (BODYSTRUCTURE)FetchResponse.getItem(r, msgno, com/sun/mail/imap/protocol/BODYSTRUCTURE);
        if(response.isNO())
        {
            return null;
        } else
        {
            handleResult(response);
            return null;
        }
    }

    public BODY peekBody(int msgno, String section)
        throws ProtocolException
    {
        return fetchBody(msgno, section, true);
    }

    public BODY fetchBody(int msgno, String section)
        throws ProtocolException
    {
        return fetchBody(msgno, section, false);
    }

    protected BODY fetchBody(int msgno, String section, boolean peek)
        throws ProtocolException
    {
        Response r[];
        if(peek)
            r = fetch(msgno, (new StringBuilder()).append("BODY.PEEK[").append(section != null ? (new StringBuilder()).append(section).append("]").toString() : "]").toString());
        else
            r = fetch(msgno, (new StringBuilder()).append("BODY[").append(section != null ? (new StringBuilder()).append(section).append("]").toString() : "]").toString());
        notifyResponseHandlers(r);
        Response response = r[r.length - 1];
        if(response.isOK())
            return (BODY)FetchResponse.getItem(r, msgno, com/sun/mail/imap/protocol/BODY);
        if(response.isNO())
        {
            return null;
        } else
        {
            handleResult(response);
            return null;
        }
    }

    public BODY peekBody(int msgno, String section, int start, int size)
        throws ProtocolException
    {
        return fetchBody(msgno, section, start, size, true, null);
    }

    public BODY fetchBody(int msgno, String section, int start, int size)
        throws ProtocolException
    {
        return fetchBody(msgno, section, start, size, false, null);
    }

    public BODY peekBody(int msgno, String section, int start, int size, ByteArray ba)
        throws ProtocolException
    {
        return fetchBody(msgno, section, start, size, true, ba);
    }

    public BODY fetchBody(int msgno, String section, int start, int size, ByteArray ba)
        throws ProtocolException
    {
        return fetchBody(msgno, section, start, size, false, ba);
    }

    protected BODY fetchBody(int msgno, String section, int start, int size, boolean peek, ByteArray ba)
        throws ProtocolException
    {
        this.ba = ba;
        Response r[] = fetch(msgno, (new StringBuilder()).append(peek ? "BODY.PEEK[" : "BODY[").append(section != null ? (new StringBuilder()).append(section).append("]<").toString() : "]<").append(String.valueOf(start)).append(".").append(String.valueOf(size)).append(">").toString());
        notifyResponseHandlers(r);
        Response response = r[r.length - 1];
        if(response.isOK())
            return (BODY)FetchResponse.getItem(r, msgno, com/sun/mail/imap/protocol/BODY);
        if(response.isNO())
        {
            return null;
        } else
        {
            handleResult(response);
            return null;
        }
    }

    protected ByteArray getResponseBuffer()
    {
        ByteArray ret = ba;
        ba = null;
        return ret;
    }

    public RFC822DATA fetchRFC822(int msgno, String what)
        throws ProtocolException
    {
        Response r[] = fetch(msgno, what != null ? (new StringBuilder()).append("RFC822.").append(what).toString() : "RFC822");
        notifyResponseHandlers(r);
        Response response = r[r.length - 1];
        if(response.isOK())
            return (RFC822DATA)FetchResponse.getItem(r, msgno, com/sun/mail/imap/protocol/RFC822DATA);
        if(response.isNO())
        {
            return null;
        } else
        {
            handleResult(response);
            return null;
        }
    }

    public Flags fetchFlags(int msgno)
        throws ProtocolException
    {
        Flags flags = null;
        Response r[] = fetch(msgno, "FLAGS");
        int i = 0;
        for(int len = r.length; i < len; i++)
        {
            if(r[i] == null || !(r[i] instanceof FetchResponse) || ((FetchResponse)r[i]).getNumber() != msgno)
                continue;
            FetchResponse fr = (FetchResponse)r[i];
            if((flags = (Flags)fr.getItem(javax/mail/Flags)) == null)
                continue;
            r[i] = null;
            break;
        }

        notifyResponseHandlers(r);
        handleResult(r[r.length - 1]);
        return flags;
    }

    public UID fetchUID(int msgno)
        throws ProtocolException
    {
        Response r[] = fetch(msgno, "UID");
        notifyResponseHandlers(r);
        Response response = r[r.length - 1];
        if(response.isOK())
            return (UID)FetchResponse.getItem(r, msgno, com/sun/mail/imap/protocol/UID);
        if(response.isNO())
        {
            return null;
        } else
        {
            handleResult(response);
            return null;
        }
    }

    public UID fetchSequenceNumber(long uid)
        throws ProtocolException
    {
        UID u = null;
        Response r[] = fetch(String.valueOf(uid), "UID", true);
        int i = 0;
        for(int len = r.length; i < len; i++)
        {
            if(r[i] == null || !(r[i] instanceof FetchResponse))
                continue;
            FetchResponse fr = (FetchResponse)r[i];
            if((u = (UID)fr.getItem(com/sun/mail/imap/protocol/UID)) == null)
                continue;
            if(u.uid == uid)
                break;
            u = null;
        }

        notifyResponseHandlers(r);
        handleResult(r[r.length - 1]);
        return u;
    }

    public UID[] fetchSequenceNumbers(long start, long end)
        throws ProtocolException
    {
        Response r[] = fetch((new StringBuilder()).append(String.valueOf(start)).append(":").append(end != -1L ? String.valueOf(end) : "*").toString(), "UID", true);
        Vector v = new Vector();
        int i = 0;
        for(int len = r.length; i < len; i++)
        {
            if(r[i] == null || !(r[i] instanceof FetchResponse))
                continue;
            FetchResponse fr = (FetchResponse)r[i];
            UID u;
            if((u = (UID)fr.getItem(com/sun/mail/imap/protocol/UID)) != null)
                v.addElement(u);
        }

        notifyResponseHandlers(r);
        handleResult(r[r.length - 1]);
        UID ua[] = new UID[v.size()];
        v.copyInto(ua);
        return ua;
    }

    public UID[] fetchSequenceNumbers(long uids[])
        throws ProtocolException
    {
        StringBuffer sb = new StringBuffer();
        for(int i = 0; i < uids.length; i++)
        {
            if(i > 0)
                sb.append(",");
            sb.append(String.valueOf(uids[i]));
        }

        Response r[] = fetch(sb.toString(), "UID", true);
        Vector v = new Vector();
        int i = 0;
        for(int len = r.length; i < len; i++)
        {
            if(r[i] == null || !(r[i] instanceof FetchResponse))
                continue;
            FetchResponse fr = (FetchResponse)r[i];
            UID u;
            if((u = (UID)fr.getItem(com/sun/mail/imap/protocol/UID)) != null)
                v.addElement(u);
        }

        notifyResponseHandlers(r);
        handleResult(r[r.length - 1]);
        UID ua[] = new UID[v.size()];
        v.copyInto(ua);
        return ua;
    }

    public Response[] fetch(MessageSet msgsets[], String what)
        throws ProtocolException
    {
        return fetch(MessageSet.toString(msgsets), what, false);
    }

    public Response[] fetch(int start, int end, String what)
        throws ProtocolException
    {
        return fetch((new StringBuilder()).append(String.valueOf(start)).append(":").append(String.valueOf(end)).toString(), what, false);
    }

    public Response[] fetch(int msg, String what)
        throws ProtocolException
    {
        return fetch(String.valueOf(msg), what, false);
    }

    private Response[] fetch(String msgSequence, String what, boolean uid)
        throws ProtocolException
    {
        if(uid)
            return command((new StringBuilder()).append("UID FETCH ").append(msgSequence).append(" (").append(what).append(")").toString(), null);
        else
            return command((new StringBuilder()).append("FETCH ").append(msgSequence).append(" (").append(what).append(")").toString(), null);
    }

    public void copy(MessageSet msgsets[], String mbox)
        throws ProtocolException
    {
        copy(MessageSet.toString(msgsets), mbox);
    }

    public void copy(int start, int end, String mbox)
        throws ProtocolException
    {
        copy((new StringBuilder()).append(String.valueOf(start)).append(":").append(String.valueOf(end)).toString(), mbox);
    }

    private void copy(String msgSequence, String mbox)
        throws ProtocolException
    {
        mbox = BASE64MailboxEncoder.encode(mbox);
        Argument args = new Argument();
        args.writeAtom(msgSequence);
        args.writeString(mbox);
        simpleCommand("COPY", args);
    }

    public void storeFlags(MessageSet msgsets[], Flags flags, boolean set)
        throws ProtocolException
    {
        storeFlags(MessageSet.toString(msgsets), flags, set);
    }

    public void storeFlags(int start, int end, Flags flags, boolean set)
        throws ProtocolException
    {
        storeFlags((new StringBuilder()).append(String.valueOf(start)).append(":").append(String.valueOf(end)).toString(), flags, set);
    }

    public void storeFlags(int msg, Flags flags, boolean set)
        throws ProtocolException
    {
        storeFlags(String.valueOf(msg), flags, set);
    }

    private void storeFlags(String msgset, Flags flags, boolean set)
        throws ProtocolException
    {
        Response r[];
        if(set)
            r = command((new StringBuilder()).append("STORE ").append(msgset).append(" +FLAGS ").append(createFlagList(flags)).toString(), null);
        else
            r = command((new StringBuilder()).append("STORE ").append(msgset).append(" -FLAGS ").append(createFlagList(flags)).toString(), null);
        notifyResponseHandlers(r);
        handleResult(r[r.length - 1]);
    }

    private String createFlagList(Flags flags)
    {
        StringBuffer sb = new StringBuffer();
        sb.append("(");
        javax.mail.Flags.Flag sf[] = flags.getSystemFlags();
        boolean first = true;
        for(int i = 0; i < sf.length; i++)
        {
            javax.mail.Flags.Flag f = sf[i];
            String s;
            if(f == javax.mail.Flags.Flag.ANSWERED)
                s = "\\Answered";
            else
            if(f == javax.mail.Flags.Flag.DELETED)
                s = "\\Deleted";
            else
            if(f == javax.mail.Flags.Flag.DRAFT)
                s = "\\Draft";
            else
            if(f == javax.mail.Flags.Flag.FLAGGED)
                s = "\\Flagged";
            else
            if(f == javax.mail.Flags.Flag.RECENT)
            {
                s = "\\Recent";
            } else
            {
                if(f != javax.mail.Flags.Flag.SEEN)
                    continue;
                s = "\\Seen";
            }
            if(first)
                first = false;
            else
                sb.append(' ');
            sb.append(s);
        }

        String uf[] = flags.getUserFlags();
        for(int i = 0; i < uf.length; i++)
        {
            if(first)
                first = false;
            else
                sb.append(' ');
            sb.append(uf[i]);
        }

        sb.append(")");
        return sb.toString();
    }

    public int[] search(MessageSet msgsets[], SearchTerm term)
        throws ProtocolException, SearchException
    {
        return search(MessageSet.toString(msgsets), term);
    }

    public int[] search(SearchTerm term)
        throws ProtocolException, SearchException
    {
        return search("ALL", term);
    }

    private int[] search(String msgSequence, SearchTerm term)
        throws ProtocolException, SearchException
    {
        getSearchSequence();
        if(SearchSequence.isAscii(term))
            try
            {
                return issueSearch(msgSequence, term, null);
            }
            catch(IOException ioex) { }
        for(int i = 0; i < searchCharsets.length; i++)
        {
            if(searchCharsets[i] == null)
                continue;
            try
            {
                return issueSearch(msgSequence, term, searchCharsets[i]);
            }
            catch(CommandFailedException cfx)
            {
                searchCharsets[i] = null;
            }
            catch(IOException ioex) { }
            catch(ProtocolException pex)
            {
                throw pex;
            }
            catch(SearchException sex)
            {
                throw sex;
            }
        }

        throw new SearchException("Search failed");
    }

    private int[] issueSearch(String msgSequence, SearchTerm term, String charset)
        throws ProtocolException, SearchException, IOException
    {
        Argument args = getSearchSequence().generateSequence(term, charset != null ? MimeUtility.javaCharset(charset) : null);
        args.writeAtom(msgSequence);
        Response r[];
        if(charset == null)
            r = command("SEARCH", args);
        else
            r = command((new StringBuilder()).append("SEARCH CHARSET ").append(charset).toString(), args);
        Response response = r[r.length - 1];
        int matches[] = null;
        if(response.isOK())
        {
            Vector v = new Vector();
            int i = 0;
            for(int len = r.length; i < len; i++)
            {
                if(!(r[i] instanceof IMAPResponse))
                    continue;
                IMAPResponse ir = (IMAPResponse)r[i];
                if(!ir.keyEquals("SEARCH"))
                    continue;
                int num;
                while((num = ir.readNumber()) != -1) 
                    v.addElement(new Integer(num));
                r[i] = null;
            }

            int vsize = v.size();
            matches = new int[vsize];
            for(int i = 0; i < vsize; i++)
                matches[i] = ((Integer)v.elementAt(i)).intValue();

        }
        notifyResponseHandlers(r);
        handleResult(response);
        return matches;
    }

    protected SearchSequence getSearchSequence()
    {
        if(searchSequence == null)
            searchSequence = new SearchSequence();
        return searchSequence;
    }

    public int[] sort(SortTerm term[], SearchTerm sterm)
        throws ProtocolException, SearchException
    {
        if(!hasCapability("SORT*"))
            throw new BadCommandException("SORT not supported");
        if(term == null || term.length == 0)
            throw new BadCommandException("Must have at least one sort term");
        Argument args = new Argument();
        Argument sargs = new Argument();
        for(int i = 0; i < term.length; i++)
            sargs.writeAtom(term[i].toString());

        args.writeArgument(sargs);
        args.writeAtom("UTF-8");
        if(sterm != null)
            try
            {
                args.append(getSearchSequence().generateSequence(sterm, "UTF-8"));
            }
            catch(IOException ioex)
            {
                throw new SearchException(ioex.toString());
            }
        else
            args.writeAtom("ALL");
        Response r[] = command("SORT", args);
        Response response = r[r.length - 1];
        int matches[] = null;
        if(response.isOK())
        {
            Vector v = new Vector();
            int i = 0;
            for(int len = r.length; i < len; i++)
            {
                if(!(r[i] instanceof IMAPResponse))
                    continue;
                IMAPResponse ir = (IMAPResponse)r[i];
                if(!ir.keyEquals("SORT"))
                    continue;
                int num;
                while((num = ir.readNumber()) != -1) 
                    v.addElement(new Integer(num));
                r[i] = null;
            }

            int vsize = v.size();
            matches = new int[vsize];
            for(int i = 0; i < vsize; i++)
                matches[i] = ((Integer)v.elementAt(i)).intValue();

        }
        notifyResponseHandlers(r);
        handleResult(response);
        return matches;
    }

    public Namespaces namespace()
        throws ProtocolException
    {
        if(!hasCapability("NAMESPACE"))
            throw new BadCommandException("NAMESPACE not supported");
        Response r[] = command("NAMESPACE", null);
        Namespaces namespace = null;
        Response response = r[r.length - 1];
        if(response.isOK())
        {
            int i = 0;
            for(int len = r.length; i < len; i++)
            {
                if(!(r[i] instanceof IMAPResponse))
                    continue;
                IMAPResponse ir = (IMAPResponse)r[i];
                if(!ir.keyEquals("NAMESPACE"))
                    continue;
                if(namespace == null)
                    namespace = new Namespaces(ir);
                r[i] = null;
            }

        }
        notifyResponseHandlers(r);
        handleResult(response);
        return namespace;
    }

    public Quota[] getQuotaRoot(String mbox)
        throws ProtocolException
    {
        if(!hasCapability("QUOTA"))
            throw new BadCommandException("GETQUOTAROOT not supported");
        mbox = BASE64MailboxEncoder.encode(mbox);
        Argument args = new Argument();
        args.writeString(mbox);
        Response r[] = command("GETQUOTAROOT", args);
        Response response = r[r.length - 1];
        Hashtable tab = new Hashtable();
        if(response.isOK())
        {
            int i = 0;
            for(int len = r.length; i < len; i++)
            {
                if(!(r[i] instanceof IMAPResponse))
                    continue;
                IMAPResponse ir = (IMAPResponse)r[i];
                if(ir.keyEquals("QUOTAROOT"))
                {
                    ir.readAtomString();
                    for(String root = null; (root = ir.readAtomString()) != null && root.length() > 0; tab.put(root, new Quota(root)));
                    r[i] = null;
                    continue;
                }
                if(!ir.keyEquals("QUOTA"))
                    continue;
                Quota quota = parseQuota(ir);
                Quota q = (Quota)tab.get(quota.quotaRoot);
                if(q != null)
                    if(q.resources == null);
                tab.put(quota.quotaRoot, quota);
                r[i] = null;
            }

        }
        notifyResponseHandlers(r);
        handleResult(response);
        Quota qa[] = new Quota[tab.size()];
        Enumeration e = tab.elements();
        for(int i = 0; e.hasMoreElements(); i++)
            qa[i] = (Quota)e.nextElement();

        return qa;
    }

    public Quota[] getQuota(String root)
        throws ProtocolException
    {
        if(!hasCapability("QUOTA"))
            throw new BadCommandException("QUOTA not supported");
        Argument args = new Argument();
        args.writeString(root);
        Response r[] = command("GETQUOTA", args);
        Quota quota = null;
        Vector v = new Vector();
        Response response = r[r.length - 1];
        if(response.isOK())
        {
            int i = 0;
            for(int len = r.length; i < len; i++)
            {
                if(!(r[i] instanceof IMAPResponse))
                    continue;
                IMAPResponse ir = (IMAPResponse)r[i];
                if(ir.keyEquals("QUOTA"))
                {
                    quota = parseQuota(ir);
                    v.addElement(quota);
                    r[i] = null;
                }
            }

        }
        notifyResponseHandlers(r);
        handleResult(response);
        Quota qa[] = new Quota[v.size()];
        v.copyInto(qa);
        return qa;
    }

    public void setQuota(Quota quota)
        throws ProtocolException
    {
        if(!hasCapability("QUOTA"))
            throw new BadCommandException("QUOTA not supported");
        Argument args = new Argument();
        args.writeString(quota.quotaRoot);
        Argument qargs = new Argument();
        if(quota.resources != null)
        {
            for(int i = 0; i < quota.resources.length; i++)
            {
                qargs.writeAtom(quota.resources[i].name);
                qargs.writeNumber(quota.resources[i].limit);
            }

        }
        args.writeArgument(qargs);
        Response r[] = command("SETQUOTA", args);
        Response response = r[r.length - 1];
        notifyResponseHandlers(r);
        handleResult(response);
    }

    private Quota parseQuota(Response r)
        throws ParsingException
    {
        String quotaRoot = r.readAtomString();
        Quota q = new Quota(quotaRoot);
        r.skipSpaces();
        if(r.readByte() != 40)
            throw new ParsingException("parse error in QUOTA");
        Vector v = new Vector();
        do
        {
            if(r.peekByte() == 41)
                break;
            String name = r.readAtom();
            if(name != null)
            {
                long usage = r.readLong();
                long limit = r.readLong();
                javax.mail.Quota.Resource res = new javax.mail.Quota.Resource(name, usage, limit);
                v.addElement(res);
            }
        } while(true);
        r.readByte();
        q.resources = new javax.mail.Quota.Resource[v.size()];
        v.copyInto(q.resources);
        return q;
    }

    public void setACL(String mbox, char modifier, ACL acl)
        throws ProtocolException
    {
        if(!hasCapability("ACL"))
            throw new BadCommandException("ACL not supported");
        mbox = BASE64MailboxEncoder.encode(mbox);
        Argument args = new Argument();
        args.writeString(mbox);
        args.writeString(acl.getName());
        String rights = acl.getRights().toString();
        if(modifier == '+' || modifier == '-')
            rights = (new StringBuilder()).append(modifier).append(rights).toString();
        args.writeString(rights);
        Response r[] = command("SETACL", args);
        Response response = r[r.length - 1];
        notifyResponseHandlers(r);
        handleResult(response);
    }

    public void deleteACL(String mbox, String user)
        throws ProtocolException
    {
        if(!hasCapability("ACL"))
        {
            throw new BadCommandException("ACL not supported");
        } else
        {
            mbox = BASE64MailboxEncoder.encode(mbox);
            Argument args = new Argument();
            args.writeString(mbox);
            args.writeString(user);
            Response r[] = command("DELETEACL", args);
            Response response = r[r.length - 1];
            notifyResponseHandlers(r);
            handleResult(response);
            return;
        }
    }

    public ACL[] getACL(String mbox)
        throws ProtocolException
    {
        if(!hasCapability("ACL"))
            throw new BadCommandException("ACL not supported");
        mbox = BASE64MailboxEncoder.encode(mbox);
        Argument args = new Argument();
        args.writeString(mbox);
        Response r[] = command("GETACL", args);
        Response response = r[r.length - 1];
        Vector v = new Vector();
        if(response.isOK())
        {
            int i = 0;
            for(int len = r.length; i < len; i++)
            {
                if(!(r[i] instanceof IMAPResponse))
                    continue;
                IMAPResponse ir = (IMAPResponse)r[i];
                if(!ir.keyEquals("ACL"))
                    continue;
                ir.readAtomString();
                String name = null;
                do
                {
                    if((name = ir.readAtomString()) == null)
                        break;
                    String rights = ir.readAtomString();
                    if(rights == null)
                        break;
                    ACL acl = new ACL(name, new Rights(rights));
                    v.addElement(acl);
                } while(true);
                r[i] = null;
            }

        }
        notifyResponseHandlers(r);
        handleResult(response);
        ACL aa[] = new ACL[v.size()];
        v.copyInto(aa);
        return aa;
    }

    public Rights[] listRights(String mbox, String user)
        throws ProtocolException
    {
        if(!hasCapability("ACL"))
            throw new BadCommandException("ACL not supported");
        mbox = BASE64MailboxEncoder.encode(mbox);
        Argument args = new Argument();
        args.writeString(mbox);
        args.writeString(user);
        Response r[] = command("LISTRIGHTS", args);
        Response response = r[r.length - 1];
        Vector v = new Vector();
        if(response.isOK())
        {
            int i = 0;
            for(int len = r.length; i < len; i++)
            {
                if(!(r[i] instanceof IMAPResponse))
                    continue;
                IMAPResponse ir = (IMAPResponse)r[i];
                if(!ir.keyEquals("LISTRIGHTS"))
                    continue;
                ir.readAtomString();
                ir.readAtomString();
                String rights;
                while((rights = ir.readAtomString()) != null) 
                    v.addElement(new Rights(rights));
                r[i] = null;
            }

        }
        notifyResponseHandlers(r);
        handleResult(response);
        Rights ra[] = new Rights[v.size()];
        v.copyInto(ra);
        return ra;
    }

    public Rights myRights(String mbox)
        throws ProtocolException
    {
        if(!hasCapability("ACL"))
            throw new BadCommandException("ACL not supported");
        mbox = BASE64MailboxEncoder.encode(mbox);
        Argument args = new Argument();
        args.writeString(mbox);
        Response r[] = command("MYRIGHTS", args);
        Response response = r[r.length - 1];
        Rights rights = null;
        if(response.isOK())
        {
            int i = 0;
            for(int len = r.length; i < len; i++)
            {
                if(!(r[i] instanceof IMAPResponse))
                    continue;
                IMAPResponse ir = (IMAPResponse)r[i];
                if(!ir.keyEquals("MYRIGHTS"))
                    continue;
                ir.readAtomString();
                String rs = ir.readAtomString();
                if(rights == null)
                    rights = new Rights(rs);
                r[i] = null;
            }

        }
        notifyResponseHandlers(r);
        handleResult(response);
        return rights;
    }

    public synchronized void idleStart()
        throws ProtocolException
    {
        if(!hasCapability("IDLE"))
            throw new BadCommandException("IDLE not supported");
        Vector v = new Vector();
        boolean done = false;
        Response r = null;
        try
        {
            idleTag = writeCommand("IDLE", null);
        }
        catch(LiteralException lex)
        {
            v.addElement(lex.getResponse());
            done = true;
        }
        catch(Exception ex)
        {
            v.addElement(Response.byeResponse(ex));
            done = true;
        }
        do
        {
            if(done)
                break;
            try
            {
                r = readResponse();
            }
            catch(IOException ioex)
            {
                r = Response.byeResponse(ioex);
            }
            catch(ProtocolException pex)
            {
                continue;
            }
            v.addElement(r);
            if(r.isContinuation() || r.isBYE())
                done = true;
        } while(true);
        Response responses[] = new Response[v.size()];
        v.copyInto(responses);
        r = responses[responses.length - 1];
        notifyResponseHandlers(responses);
        if(!r.isContinuation())
            handleResult(r);
    }

    public synchronized Response readIdleResponse()
    {
        if(idleTag == null)
            return null;
        Response r;
        for(r = null; r == null;)
            try
            {
                r = readResponse();
            }
            catch(InterruptedIOException iioex)
            {
                if(iioex.bytesTransferred == 0)
                    r = null;
                else
                    r = Response.byeResponse(iioex);
            }
            catch(IOException ioex)
            {
                r = Response.byeResponse(ioex);
            }
            catch(ProtocolException pex)
            {
                r = Response.byeResponse(pex);
            }

        return r;
    }

    public boolean processIdleResponse(Response r)
        throws ProtocolException
    {
        Response responses[] = new Response[1];
        responses[0] = r;
        boolean done = false;
        notifyResponseHandlers(responses);
        if(r.isBYE())
            done = true;
        if(r.isTagged() && r.getTag().equals(idleTag))
            done = true;
        if(done)
            idleTag = null;
        handleResult(r);
        return !done;
    }

    public void idleAbort()
        throws ProtocolException
    {
        OutputStream os = getOutputStream();
        try
        {
            os.write(DONE);
            os.flush();
        }
        catch(IOException ex) { }
    }

    private boolean connected;
    private boolean rev1;
    private boolean noauthdebug;
    private boolean authenticated;
    private Map capabilities;
    private List authmechs;
    protected SearchSequence searchSequence;
    protected String searchCharsets[];
    private String name;
    private SaslAuthenticator saslAuthenticator;
    private ByteArray ba;
    private static final byte CRLF[] = {
        13, 10
    };
    private static final FetchItem fetchItems[] = new FetchItem[0];
    private volatile String idleTag;
    private static final byte DONE[] = {
        68, 79, 78, 69, 13, 10
    };

}
